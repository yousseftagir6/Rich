<!doctype html>
<html lang="fr">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Signaux précis — 1D only (Binance USDT Top)</title>
<style>
:root{--bg:#0f1115;--card:#131722;--fg:#eaeef5;--muted:#9aa3b2;--buy:#10b981;--sell:#ef4444;}
html,body{margin:0;background:var(--bg);color:var(--fg);font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif}
.wrap{max-width:1100px;margin:14px auto;padding:12px}
.controls{display:flex;gap:8px;align-items:center;flex-wrap:wrap;margin-bottom:12px}
select,button{background:#0f1724;color:var(--fg);border:1px solid #223;border-radius:10px;padding:8px 10px}
.card{background:#0f131a;border:1px solid #202633;border-radius:12px;padding:12px;margin-bottom:12px}
table{width:100%;border-collapse:collapse}
th,td{padding:8px;border-bottom:1px solid #202633;font-size:13px}
.pill{padding:6px 10px;border-radius:999px;font-weight:700;font-size:12px}
.pill.buy{background:rgba(16,185,129,.12);color:#86efac;border:1px solid rgba(16,185,129,.2)}
.pill.sell{background:rgba(239,68,68,.12);color:#fecaca;border:1px solid rgba(239,68,68,.2)}
.pct{font-weight:800}
#chart{height:56vh;min-height:320px}
.toast{position:fixed;right:18px;bottom:18px;background:#0e1624;padding:10px;border-radius:8px;border:1px solid #1e293b}
.small{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<div class="wrap">
  <h1>Signaux — 1D uniquement (Binance USDT, top 200)</h1>

  <div class="controls card">
    <button id="analyzeBtn">Analyser 1D</button>
    <button id="backtestBtn">Backtest accéléré</button>
    <button id="downloadBtn">Télécharger la page</button>
    <span id="status" class="small">Prêt</span>
    <div style="margin-left:auto" class="small">Éducatif — données publiques Binance</div>
  </div>

  <div class="card">
    <div style="display:flex;gap:12px;align-items:flex-start">
      <div style="flex:1">
        <div class="small">Résultats (1D)</div>
        <table>
          <thead><tr><th>Actif</th><th>Prix</th><th>Signal</th><th>Fiabilité</th><th>Indicateurs</th><th>Maj</th></tr></thead>
          <tbody id="rows_1d"></tbody>
        </table>
      </div>
      <div style="width:420px">
        <div id="chart" class="card">Cliquez un actif pour voir le graphique</div>
        <div id="signalBox" class="card small">—</div>
      </div>
    </div>
  </div>

  <div class="card">
    <div style="display:flex;justify-content:space-between;align-items:center">
      <div class="small">Historique local (>=80% uniquement)</div>
      <div>
        <button id="downloadHistory">Télécharger CSV</button>
        <button id="clearHistory">Effacer</button>
      </div>
    </div>
    <div style="margin-top:8px" id="histSummary" class="small">Aucune entrée</div>
    <table style="margin-top:8px">
      <thead><tr><th>Actif</th><th>Signal</th><th>Fiab.</th><th>Entrée</th><th>Sortie</th><th>Verdict</th><th>Horodatage</th></tr></thead>
      <tbody id="historyRows"></tbody>
    </table>
  </div>

</div>

<div id="toast" class="toast" style="display:none"></div>

<script>
/* Configuration */
const MAX_SYMBOLS = 200;
const HISTORY_KEY = 'trade_history_1d_v1';
const MIN_HIST_CONF = 80;

/* UI refs */
const rows1d = document.getElementById('rows_1d');
const status = document.getElementById('status');
const signalBox = document.getElementById('signalBox');
const historyRows = document.getElementById('historyRows');
const histSummary = document.getElementById('histSummary');

/* Symbols set (will be filled from Binance) */
let sets = { all: [] };

/* Simple toast */
function toast(msg, t=3000){ const el=document.getElementById('toast'); el.textContent=msg; el.style.display='block'; setTimeout(()=>el.style.display='none',t); }

/* ====== Fetch top USDT pairs from Binance (by quote volume) ====== */
async function fetchTopUsdtSymbols(limit = MAX_SYMBOLS){
  status.textContent = 'Chargement symboles Binance...';
  try {
    const r = await fetch('https://api.binance.com/api/v3/exchangeInfo');
    const info = await r.json();
    const usdt = info.symbols.filter(s => s.quoteAsset==='USDT' && s.status==='TRADING').map(s=>s.symbol);
    const tickersR = await fetch('https://api.binance.com/api/v3/ticker/24hr');
    const tickers = await tickersR.json();
    const volMap = {};
    tickers.forEach(t => volMap[t.symbol] = parseFloat(t.quoteVolume||0));
    usdt.sort((a,b)=>(volMap[b]||0)-(volMap[a]||0));
    const limited = usdt.slice(0,limit);
    sets.all = limited.map(s=>({binance:s, name:s.replace('USDT','/USDT'), tv:`BINANCE:${s}`}));
    status.textContent = `Symboles chargés: ${sets.all.length}`;
    return true;
  } catch(e){
    console.error(e); status.textContent = 'Erreur chargement symboles — fallback 7 majeurs';
    sets.all = ['BTCUSDT','ETHUSDT','BNBUSDT','SOLUSDT','XRPUSDT','ADAUSDT','DOGEUSDT'].map(s=>({binance:s,name:s.replace('USDT','/USDT'),tv:`BINANCE:${s}`}));
    return false;
  }
}

/* ====== OHLC fetch convenience ====== */
async function fetchOHLC(symbol, interval='1d', limit=200){
  const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
  const r = await fetch(url);
  const j = await r.json();
  return j.map(k=>({time:+k[0], open:+k[1], high:+k[2], low:+k[3], close:+k[4], volume:+k[5]}));
}
async function fetchLastPrice(symbol){
  const r = await fetch(`https://api.binance.com/api/v3/ticker/price?symbol=${symbol}`);
  const j = await r.json();
  return +j.price;
}

/* ====== Indicators (essential ones + OBV & CMF) ====== */
function sma(arr,n){ const out=Array(arr.length).fill(null); let s=0; for(let i=0;i<arr.length;i++){ s+=arr[i]; if(i>=n) s-=arr[i-n]; if(i>=n-1) out[i]=s/n; } return out; }
function ema(arr,n){ const out=Array(arr.length).fill(null); const k=2/(n+1); let prev=null; for(let i=0;i<arr.length;i++){ if(prev==null){ out[i]=arr[i]; prev=arr[i]; } else{ prev=arr[i]*k + prev*(1-k); out[i]=prev; } } return out; }
function rsi(values,n=14){ const out=Array(values.length).fill(null); let g=0,l=0; for(let i=1;i<values.length;i++){ const ch = values[i]-values[i-1]; const up=Math.max(ch,0), dn=Math.max(-ch,0); if(i<=n){ g+=up; l+=dn; if(i===n){ const rs = l===0?1000:(g/n)/(l/n); out[i]=100-100/(1+rs); } } else { g=(g*(n-1)+up)/n; l=(l*(n-1)+dn)/n; const rs = l===0?1000:g/l; out[i]=100-100/(1+rs); } } return out; }
function macd(values,fast=12,slow=26,signal=9){ const ef=ema(values,fast), es=ema(values,slow); const line = values.map((_,i)=>(ef[i]!=null&&es[i]!=null)?ef[i]-es[i]:null); const start=line.findIndex(v=>v!=null); const valid=line.slice(start); const sig = ema(valid,signal); const signalLine=Array(line.length).fill(null); for(let i=0;i<sig.length;i++) signalLine[start+i]=sig[i]; const hist=line.map((v,i)=>(v!=null&&signalLine[i]!=null)?v-signalLine[i]:null); return {macdLine:line, signalLine, hist}; }
function bollinger(values,n=20,m=2){ const out=Array(values.length).fill(null); for(let i=0;i<values.length;i++){ if(i<n-1) continue; const slice=values.slice(i-n+1,i+1); const mean = slice.reduce((a,b)=>a+b,0)/n; const std = Math.sqrt(slice.reduce((a,b)=>a+(b-mean)*(b-mean),0)/n); out[i]={mid:mean,upper:mean+m*std,lower:mean-m*std}; } return out; }
/* OBV */
function obv(close, volume){ const out=Array(close.length).fill(null); let running=0; out[0]=0; for(let i=1;i<close.length;i++){ if(close[i]>close[i-1]) running += volume[i]; else if(close[i]<close[i-1]) running -= volume[i]; out[i]=running; } return out; }
/* CMF: Chaikin Money Flow (lookback default 20) */
function cmf(high, low, close, volume, n=20){ const mfv=[]; for(let i=0;i<close.length;i++){ const denom = high[i]-low[i]; const mfm = denom===0 ? 0 : ((close[i]-low[i]) - (high[i]-close[i])) / denom; mfv.push(mfm * volume[i]); } const out=Array(close.length).fill(null); for(let i=0;i<close.length;i++){ if(i<n-1) continue; const num = mfv.slice(i-n+1,i+1).reduce((a,b)=>a+b,0); const den = volume.slice(i-n+1,i+1).reduce((a,b)=>a+b,0); out[i] = den===0 ? 0 : num/den; } return out; }

/* Note: Stochastic & VWAP code kept but intentionally NOT used in evaluate() (disabled) */

/* ====== Scoring (evaluate) - 1D focused, with OBV & CMF included; Stochastic/VWAP disabled ====== */
function evaluate(close, high, low, volume){
  const i = close.length - 1;
  const contribs = [];
  const weight = 1.0;

  const sma50 = sma(close,50), sma200 = sma(close,200);
  if(sma50[i]!=null && sma200[i]!=null) contribs.push({w:2.0, s: sma50[i]>sma200[i]?+1:-1, name:'SMA50/200'});

  const ema12 = ema(close,12), ema26 = ema(close,26);
  if(ema12[i]!=null && ema26[i]!=null) contribs.push({w:1.6, s: ema12[i]>ema26[i]?+1:-1, name:'EMA12/26'});

  const rsi14 = rsi(close,14);
  if(rsi14[i]!=null){ let s=0; if(rsi14[i]<30) s=+1; else if(rsi14[i]>70) s=-1; else if(rsi14[i]>55) s=-0.5; else if(rsi14[i]<45) s=+0.5; contribs.push({w:1.2, s, name:'RSI'}); }

  const mac = macd(close);
  if(mac.macdLine[i]!=null && mac.signalLine[i]!=null) contribs.push({w:1.8, s: mac.macdLine[i] > mac.signalLine[i] ? +1 : -1, name:'MACD'});

  const bb = bollinger(close,20,2);
  if(bb[i]!=null){ let s=0; if(close[i] < bb[i].lower) s=+1; else if(close[i] > bb[i].upper) s=-1; contribs.push({w:0.9, s, name:'Bollinger'}); }

  const obvArr = obv(close, volume);
  if(obvArr[i]!=null){ const obvSma = sma(obvArr,20); if(obvSma[i]!=null) contribs.push({w:1.6, s: obvArr[i] > obvSma[i] ? +1 : -1, name:'OBV'}); }

  const cmfArr = cmf(high, low, close, volume, 20);
  if(cmfArr[i]!=null) contribs.push({w:1.6, s: cmfArr[i] > 0 ? +1 : -1, name:'CMF'});

  // Momentum
  if(close[i]!=null && close[i-1]!=null) contribs.push({w:1.0, s: close[i] > close[i-1] ? +1 : -1, name:'Momentum'});

  // SuperTrend simplified using ATR (approx)
  function atr(high, low, close, n=14){ const out=Array(close.length).fill(null); for(let k=1;k<close.length;k++){ const tr = Math.max(high[k]-low[k], Math.abs(high[k]-close[k-1]), Math.abs(low[k]-close[k-1])); out[k]=tr; } // simple moving avg of TR for ATR
    const atrOut=Array(close.length).fill(null); for(let k=n;k<out.length;k++){ const s = out.slice(k-n+1,k+1).reduce((a,b)=>a+b,0)/n; atrOut[k]=s; } return atrOut; }
  const atrArr = atr(high, low, close, 14);
  // crude supertrend: price > sma200 -> bullish, else bearish (as extra filter)
  if(sma200[i]!=null) contribs.push({w:1.4, s: close[i] > sma200[i] ? +1 : -1, name:'SMA200 filter'});

  let totalW=0, totalScore=0;
  contribs.forEach(c=>{ totalW += c.w; totalScore += c.w * c.s; });
  const norm = totalW>0 ? totalScore/totalW : 0;
  const confidence = Math.round(Math.min(100, Math.max(0, 50 + 50*norm)));
  return { signal: norm>0 ? 'BUY' : 'SELL', confidence, contribs, score: norm };
}

/* ====== Analyze one asset (1D) ====== */
async function analyzeAsset(asset){
  try {
    const ohlc = await fetchOHLC(asset.binance, '1d', 400);
    const close = ohlc.map(o=>o.close), high = ohlc.map(o=>o.high), low = ohlc.map(o=>o.low), volume = ohlc.map(o=>o.volume);
    const lastPrice = await fetchLastPrice(asset.binance);
    const res = evaluate(close, high, low, volume);
    return { asset, price: lastPrice, signal: res.signal, confidence: res.confidence, contribs: res.contribs, timestamp: Date.now() };
  } catch(e){
    console.error('analyzeAsset error', asset, e);
    return null;
  }
}

/* ====== Bulk analyze (batched to avoid rate limits) ====== */
async function analyzeAll(){
  status.textContent = 'Analyse 1D en cours...';
  rows1d.innerHTML = '';
  const list = sets.all;
  const batchSize = 4;
  const results = [];
  for(let i=0;i<list.length;i+=batchSize){
    const batch = list.slice(i,i+batchSize);
    const promises = batch.map(a=>analyzeAsset(a));
    const settled = await Promise.all(promises);
    settled.forEach(s=>{ if(s) results.push(s); });
    status.textContent = `Analyse en cours: ${Math.min(i+batchSize, list.length)}/${list.length}`;
    await new Promise(r=>setTimeout(r, 600)); // small pause
  }
  results.sort((a,b)=>b.confidence - a.confidence);
  renderResults(results);
  status.textContent = 'Analyse terminée';
  return results;
}

/* ====== Render results ====== */
function formatPrice(p){ return p>100? p.toFixed(2): p.toFixed(6); }
function renderResults(results){
  rows1d.innerHTML = '';
  const filtered = results.filter(r=>r.confidence >= 0); // keep all, UI can filter
  filtered.forEach(r=>{
    const tr = document.createElement('tr');
    tr.onclick = ()=>{ loadChart(r.asset.tv); signalBox.innerHTML = `<div><strong>${r.asset.name}</strong> — ${r.signal} (${r.confidence}%)</div><div class="small">Indicators: ${r.contribs.map(c=>c.name).join(', ')}</div>`; };
    tr.innerHTML = `<td>${r.asset.name}</td><td>${formatPrice(r.price)}</td><td><span class="pill ${r.signal.toLowerCase()}">${r.signal}</span></td><td><span class="pct">${r.confidence}%</span></td><td>${r.contribs.length} ind.</td><td class="small">now</td>`;
    rows1d.appendChild(tr);
    if(r.confidence >= MIN_HIST_CONF) addHistoryIfNew(r);
  });
}

/* ====== Simple TradingView chart loader (if available) ====== */
function loadChart(tvSymbol){
  const el = document.getElementById('chart');
  el.innerHTML = '';
  el.textContent = 'Chart: ' + (tvSymbol||'N/A');
  // If TradingView widget is available it will be used; otherwise placeholder
  try {
    if(window.TradingView && tvSymbol){
      new TradingView.widget({container_id:'chart',symbol:tvSymbol,interval:'D',theme:'dark',autosize:true,locale:'fr'});
    }
  } catch(e){ /* ignore */ }
}

/* ====== Local history storage (only entries >= MIN_HIST_CONF) ====== */
let history = loadHistory();
function loadHistory(){ try{ return JSON.parse(localStorage.getItem(HISTORY_KEY)||'[]'); }catch(e){ return []; } }
function saveHistory(){ localStorage.setItem(HISTORY_KEY, JSON.stringify(history)); renderHistorySummary(); }
function addHistoryIfNew(result){
  if(!result || result.confidence < MIN_HIST_CONF) return;
  const minuteTs = Math.floor(result.timestamp/60000)*60000;
  const id = `${result.asset.binance}_1d_${minuteTs}`;
  if(history.some(h=>h.id===id)) return;
  const entry = { id, assetName: result.asset.name, symbol: result.asset.binance, interval:'1d', predicted: result.signal, confidence: result.confidence, price: result.price, timestamp: minuteTs, verdict:'PENDING', exitPrice:null, delta:null, indicators: result.contribs.map(c=>c.name) };
  history.unshift(entry);
  if(history.length>2000) history=history.slice(0,2000);
  saveHistory();
}

/* Render history table */
function renderHistorySummary(){
  historyRows.innerHTML = '';
  histSummary.textContent = `Entrées: ${history.length}`;
  history.forEach(h=>{
    const tr = document.createElement('tr');
    tr.innerHTML = `<td>${h.assetName}</td><td><span class="pill ${h.predicted.toLowerCase()}">${h.predicted}</span></td><td>${h.confidence}%</td><td>${h.price}</td><td>${h.exitPrice||'—'}</td><td>${h.verdict}</td><td>${new Date(h.timestamp).toLocaleString()}</td>`;
    historyRows.appendChild(tr);
  });
}

/* Download history CSV */
document.getElementById('downloadHistory').onclick = ()=>{
  if(history.length===0){ alert('Aucun historique'); return; }
  const headers = ["Actif","Intervalle","Signal","Fiabilité","Entrée","Sortie","Δ %","Verdict","Indicateurs","Horodatage"];
  const rows = history.map(h=>[h.assetName,h.interval,h.predicted,h.confidence,h.price,h.exitPrice||'',h.delta||'',h.verdict, (h.indicators||[]).join('; '), new Date(h.timestamp).toLocaleString()]);
  const csv = [headers.join(','), ...rows.map(r=>r.join(','))].join('\n');
  const blob = new Blob([csv], {type:'text/csv;charset=utf-8;'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='historique_1d.csv'; a.click(); URL.revokeObjectURL(url);
};

/* Clear history */
document.getElementById('clearHistory').onclick = ()=>{
  if(!confirm('Effacer l\'historique 1D ?')) return;
  history = []; saveHistory(); toast('Historique effacé');
};

/* Download whole page */
document.getElementById('downloadBtn').onclick = ()=>{
  const content = '<!doctype html>' + document.documentElement.outerHTML;
  const blob = new Blob([content], {type:'text/html'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href=url; a.download='index1d.html'; a.click(); URL.revokeObjectURL(url);
};

/* Backtest (simple accelerated using evaluate on historical slices) */
document.getElementById('backtestBtn').onclick = async ()=>{
  try {
    status.textContent = 'Backtest en cours...';
    const pairs = [ 'BTCUSDT', 'ETHUSDT' ]; // default sample - user can change later
    const candles = 400;
    const results = { total:0, wins:0 };
    for(const s of pairs){
      const ohlc = await fetchOHLC(s,'1d',candles);
      const close = ohlc.map(o=>o.close), high=ohlc.map(o=>o.high), low=ohlc.map(o=>o.low), vol=ohlc.map(o=>o.volume);
      for(let i=50;i<close.length-1;i++){
        const sliceC = close.slice(0,i+1), sliceH = high.slice(0,i+1), sliceL = low.slice(0,i+1), sliceV = vol.slice(0,i+1);
        const res = evaluate(sliceC,sliceH,sliceL,sliceV);
        if(res.confidence >= MIN_HIST_CONF){
          results.total++;
          const entry = close[i], exit = close[i+1];
          const isWin = (res.signal==='BUY') ? (exit>entry) : (exit<entry);
          if(isWin) results.wins++;
        }
      }
    }
    status.textContent = `Backtest terminé — Trades: ${results.total}, Wins: ${results.wins}, Winrate: ${results.total?Math.round(100*results.wins/results.total):0}%`;
  } catch(e){ console.error(e); status.textContent='Erreur backtest'; }
};

/* Init */
(async function init(){
  await fetchTopUsdtSymbols();
  renderHistorySummary();
  // run first analysis automatically
  document.getElementById('analyzeBtn').onclick = analyzeAll;
  // auto-run once
  analyzeAll();
})();
</script>

<!-- TradingView stub (optional). Keep script tag if offline widget available -->
<script src="https://s3.tradingview.com/tv.js"></script>
</body>
</html>
